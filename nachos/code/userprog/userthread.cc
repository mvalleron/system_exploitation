
#include <thread.h>
#include "system.h"
#include "copyright.h"
#include "addrspace.h"
#include "noff.h"
#include "syscall.h"
#include "new"
using namespace std;
typedef struct data{
  int f;
  int arg;
}data;


static int nbThread = 0;
void do_ThreadExit(){
  if(nbThread >0)
    --nbThread;
  else
    interrupt->Halt();
  currentThread->Finish();
}

extern void StartUserThread(void *schmurtz){
  data *tmp = (data*)schmurtz;
  int i;

    for (i = 0; i < NumTotalRegs; i++)
	machine->WriteRegister (i, 0);

    // Initial program counter -- must be location of "Start"
    machine->WriteRegister (4, tmp->arg);

    // Need to also tell MIPS where next instruction is, because
    // of branch delay possibility
    machine->WriteRegister (PCReg, tmp->f);
    machine->WriteRegister (NextPCReg, (tmp->f)+4);

    // Set the stack register to the end of the address space, where we
    // allocated the stack; but subtract off a bit, to make sure we don't
    // accidentally reference off the end!
    machine->WriteRegister (StackReg, currentThread->space->AllocateUserStack(nbThread));
    DEBUG ('a', "Initializing stack register to 0x%x\n",currentThread->space->AllocateUserStack(nbThread));
    machine->Run();
    free(schmurtz);

}

int do_ThreadCreate(int f,int arg){
  ++nbThread;
  Thread* newThread = new Thread("new thread");
  if(newThread == NULL){
    return -1;
  }
  data* schmurtz = new data();
  schmurtz->f = f;
  schmurtz->arg = arg;
  newThread->Start(StartUserThread,schmurtz);
  return 0;
}
